-문제-
사내 프로젝트를 수정해가며 useRef를 연습하던 도중 문제가 발생했다.
input 태그에 ref={refInput} 속성을 넣어줬으나 input이 저장되는 것이 아닌 undefined 가 발생했다.
원인은 프로젝트 내에 있는 ...register(...)에 있었다.
register은 useForm hook이었던것.
hook으로 인한 언마운트가 문제가 되었던거 같다.
정확한 원인을 알기위해서는 hook 과 연관지어 라이프 싸이클을 다시 공부해볼 필요가 있어 보였다.
-스프링-
AOP POINTcut 표현식
특정 조건에 의해 필터링된 Joinpoint로 수많은 Joinpoint 중에 특정 메서드에서만 공통기능을 수행시키기 위하여 사용한다.

지시자의 종류
1. execution: 가장 정교한 포인트컷을 만들 수 있다. (리턴타입 패키지경로 클래스명 메서드명(매개변수))


-리액트-
React Hook lifeCycle
React Hook은 함수형 컴포너느에서 클래스형 컴포넌트의 기능을 구현한 개념이다.
때문에 React Hook lifeCycle을 알기 위해서는 React lifeCycle의 기능들을 알고 갈 필요가 있따.

useEffect-lifeCycle
componentDidMout, componentDidUpdate 수행

리액트 최적화
필요가 없다면 최적화를 하지 않는것이 좋다.
별다른 문제가 없는데 최적화하는것은 시간낭비기 때문에 웹이나 앱이 느려졌다 판단될때만 최적화하는것이 좋다.
useState의 값이 바뀔때마다 리렌더링을 하게 된다.
이때 존재하는 자식컴포넌트도 같이 렌더링 하게 되는데 이걸 memo 등을 통해 막을 수 있다.
하지만 무분별한 사용보다 필요할때만 쓰자. 시간뿐만 아니라 memo를 쓰게 될 경우 메모라이징으로 인해 용량을 잡아먹게 된다.

리액트 쿼리
서버의 값을 클라이언트에 가져오거나, 캐싱, 값 업데이트, 에러핸들링 등 비동기 과정을 더욱 편하게 하는데 사용된다.
간단한 장점을 나열하자면 캐싱, get을 한 데이터에 대해 update를 하면 자동으로 get을 다시 수행하는 기능, 데이터가 오래되었다고 판단되면 다시 get을 하는 기능, 동일 데이터를 여러번 요청하면 한번만 요청하는 기능과 무한 스크롤, 비동기 과정의 선언적 관리, 그리고 리액트 hook과 사용하는 구조가 비슷하다는 장점이 존재한다.
웹소켓, 폴링방식의 실시간 통신 방식 업이 리액트 쿼리만으로 간편하게 해결 할 수 있다.

커스텀 hooks 만드는 법
반복되는 로직이 자주 발생할 경우 이 자주 반복되는 로직을 hook을 만들어서 쉽게 재사용 할 수 있다.
파일 이름은 상관 없지만 보통 hook을 만들때는 앞에 use라는 키워드를 붙여 이름을 짓고, 그안에 함수를 작성한다.

context
컴포넌트들이 서로 props로 값을 하나씩 전달하지 않아도 데이터를 공유할 수 있다는 말이다.
만약 context api가 없다면 props로 일일이 데이터를 넘겨줘야 한다.
component에 깊이가 깊지 않다면 괜찮겠지만 깊이가 깊다면 불편해질 수 밖에 없다.
쉽게말해 a 밑에 b와 d라는 자식 컴포넌트가, b와 d 밑에 각각 c와 e라는 자식컴포넌트가 있다 하고, 이 c의 값을 e로 옮기기 위해서는 c -> b -> a -> d -> e 순으로 데이터를 전달할 수 밖에 없다.
이런 번거로운 일을 줄이기 위해 context api를 사용하여 공용 저장공간을 만들면 props를 사용하지 않고도 자원을 공유 할수 있다.

-html-
<form> 태그
웹페이지에서 입력 양식을 의미한다.
로그인 창이나 회원가입 폼등이 이에 해당된다.
텍스트 필드에 글자를 입력하거나, 체크박스나 라이도 버튼을 클릭하고 제출 버튼을 누르면 백엔드 서버에 양식이 전달되어 정보를 처리하게 되낟.
form 태그에 사용되는 속성들로는 name(폼의 이름), action(폼 데이터가 전송되는 벡엔드 url), method(폼 전송방식으로 GET/POST) 등이 존재한다.
이런 form 태그는 화면에는 보이지 않는 추상적인 태그이기 때문에 실제로 사용자가 양식을 입력하기 위한 태그로 input 등이 사용된다.

-자바 스크립트-
dotenv
라이브러리 중 한 종류로 디폴트 값으로 현재 디렉토리에 위치한 .env 파일로 부터 환경변수를 읽어내는 일을 한다.
.env 파일에 저장해 놓은 환경 변수들을 dotenv 라이브러리를 이용해 process.env에 설정할 수 있게된다.

람다식 사용시 주의할 점
this 값을 고정시켜 버리기 때문에 잘 생각하고 써야한다.
람다식으로 선언한 함수는 선언한 시점에서 this를 확보해 버리게 된다.
그리고 확보한 값은 고정으로 설정되어 변경되지 않게 된다.
그렇기 때문에 람다를 사용할 경우 함수안에 this를 사용하는지 확인을 해줘야한다.

process.env
내장 자바스크립트 객체로 process 는 전역 객체이기 때문에 별도로 import 해야하는 모듈이 없으며 애플리케이션 어디에서든 접근이 가능하다.

-타입스크립트-
declare
컴파일러에게 해당 변수나 함수가 이미 존재한다는 것을 알리는 역할을 한다.
다른 영역의 코드에서 declare로 선언된 해당 변수나 함수를 참조할 수 있으며 declare로 선언된 부분은 자바스크립트로 컴파일 되지 않는다.
쉽게 말해 컴파일러는 해당 프로퍼티를 해석할 수 없어도 declare를 통해 코드 어딘가에 해당 프로퍼티를 생성하는 코드가 있을것이라 추측하여 에러를 발생시키지 않게 해준다.

-코드파악-
form 태그로 양식데이터가 useUserActions() 함수의 login 함수에 넘어가 login.ajax api를 호출한여 서버에서 실패나 에러를 반환하지 않을시 useSetRecoilState(userAtom); 에 id 값을 저장한다.
리코일로 전역에 선언되기에 로그아웃 전까지 로그인이 유지되는것으로 보인다.

login.js에 env 파일에서 환경변수를 불러오는 dotenv.config();를 발견하였다.
process.env 역시 존재하기에 카카오 관련 기능을 추가하기 위해 집어넣은 코드들인거 같지만 현재 미구현 상태이므로 쓰이지 않는것같다.

로그인 부분은 ref를 이용해서 focus를 맞춰졌는데 autofocus로 바꾸었다.
ref 자체가 dom을 직접 컨트롤 하기 위해 작성하는 것이므로 사용하지 않고 dom 속성 값을 정의하는것으로 원하는 결과를 만들어 낼 수 있다면 dom 속성에 직접 정의하는 것이 좋다고 한다.

formatter의 cell.getValue(); 가 어떻게 동작하는 것인지 이해하지 못했었다.
찾아보니 cell의 경우 tabulator와 연결되어 있었고 tabullator 가이드 문서에 The getValue function returns the current value for the cell. 이라고 역할을 명시해 주었다.

회원관리와 사용자 관리데이터가 다 불러와지지 않았는데 로딩바가 사라지는 문제가 존재했다.
원인은 api가 비동기 데이터 처리해주는 사이 loading바를 관리하는 setState 가 먼저 실행되는 것이 문제였다.
setState 과정 역시 비동기 데이터 처리해주는 함수안에 넣어 줌으로서 막을 수 있었다.

사용자 관리, 회원관리의 검색창 포커스를 ref를 이용해 select 값이 바껴도 자동으로 검색창에 포커스가 맞춰지도록 사용자 친화적으로 바꿔보았다.

프로젝트 내 세션 만료시 에러페이지로 이동하는 로직 확인해 보았다.
기존 공부했던 프로젝트와 달리 web.xml에서 dispatcher를 담아 처리하기에 조금 더 헤멨던거 같다.
과정을 간단하게 설명하자면 만료된 세션을 서버측에서 삭제하는 경우 클라이언트 측에서 라우터를 통해 주소 목록을 불러올때 실행되는 서버 측 로직에서 session에서 id 유무를 확인하여 없는 경우는 아무것도 조회하지 않는 쿼리를 돌려 error페이지로 이동하게 한다.
