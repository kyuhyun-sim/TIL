자바 성능 향상 방법

String 대신 StringBuilder와 StringBuffer를 사용하는 경우
String의 경우 += 과 같이 값을 더하게 되면 새로운 String 클래스의 객체가 만들어지고, 전 객체는 필요가 없어지므로 GC의 대상이 된다.
이렇게 GC 작업을 하면 할수록 시스템 CPU를 더욱 많이 사용하게 되어 응답시간이 길어지게 된다고 한다.
반면 StringBuilder와 StringBuffer 클래스의 경우 이러한 String의 불변 속성을 가지고 있지 않는 가변 속성이기에 GC 작업을 해줄 필요가 없으므로 성능을 향상시킬 수 있다.
이 두 클래스의 차이점은 동기화의 유무로 StringBuffer의 경우 동기화 키워드를 지원하여 String과 마찬가지로 멀티쓰레드 환경에서 안전하다는 점이 장점이다.
반면 StringBuilder의 경우 동기화를 지원하지 않기 때문에 멀티쓰레드 환경에서 사용하는 것은 적합하지 않지만 단일쓰레드에서의 성능은 StringBuffer보다 뛰어나다고 한다.

for문
for문에 대한 성능을 비교하는 사이트에 표시된 비교 정리글을 간추리자면 아래와 같이 정리할수 있다.
while(100%) > for(99.11%), map(90.74%), lodash_each(66.9%), angular for each(57.99%), for in(41.3%)
while이 무한 반복을 한다는 점을 생각하면 성능 측면에서는 for문을 사용해주는것이 좋아보인다.
단 for문을 사용하는 경우 일반적인 for문을 사용하는 것보다 for문을 조건절을 다음과 같이 변경해 주는 방식으로 개선 할 수 있다.
for(let i=0; i<array.length; i++) -> for(let i=0, n=array.length; i<n; i++) //기존 for문의 경우 반복할때마다 array.length에 접근하게 되어 속도 저하를 야기 할 수 있는 데 이렇게 for문 내 변수를 선언하여 length로 초기화 할 경우 바복문 동안 이 변수로 접근하여 속도를 개선할 수 있다고한다.
for(let i=0, n=array.length; i<n; i++) -> for(let i=array.length; i--;) //일반적인 반복문은 length 보다 0과 비교하는 것이 속도 측면에서 우수하기 때문에 이런식으로 수정 할 경우 더 개선이 가능해진다. 단 이경우 역순으로 반복하게 되니 고려해서 사용하는 것이 좋다.

분기문의 적절한 사용 및 단축 평가를 생각해 보기
단축평가란 컴파일러가 검사할 필요가 없다는 것을 확인 한 경우 다음 연산을 무시하고 넘어가는 것을 말한다.
예시로 if( 조건1 && 조건2 && 조건3) 이 조건절에서 조건 1이 false가 되면 2, 3 조건의 결과와 상관없이 false가 되기 때문에 그뒤 연산을 생략하고 넘어간다.
분기문의 가독성을 높이기 위해서는 첫 조건절에서 실행되는 내용은 간단하고 긍정적인 내용의 로직으로, 그뒤 로직은 복잡한 내용으로 작성해 주면 된다.

Static과 GC 관계 고려
static을 사용해 생성한 매서드나 변수는 동일한 주소의 값을 참조하며 GC의 대상도 되지 않는다.
때문에 자주 사용하며 변하지 않는 변수는 final static 으로 선언하고, 설정 파일, 코드성 데이터들을 static로 관리해주는 것이 좋다.
다만 계속 늘어나는 데이터인 Collection 객체들을 static로 선언할 경우 GC를 수행하지 않게 되어 메모리를 가득 잡아먹게되니 주의해야한다.

synchronized 적절하게 사용하기
멀티스레드 환경에서 반드시 고려해야할 점 중 하나가 스레드간의 동기화 문제다.
스레드간 서로 공유하고 수정할 수 있는 data가 있는 경우 스레드간 동기화가 되지 않은 상태에서 멀티스레드 프로그램을 돌리면 data의 안정성과 신뢰성을 보장할 수 없기 때문이다.
이를 막기위해 자바에서는 synchronized 키워드를 제공해 스레드간 동기화를 시켜 data의 thread-safe를 가능하게 해준다.
여러개의 스레드가 한개의 자원을 사용하고자 할때 현재 사용하고 이쓴ㄴ 해당 스레드를 제외하고 나머지 스레드들은 데이터에 접근 할 수 없게 막아준다.
하지만 이 Synchronized 키워드를 너무 남발하게 된다면 오히려 프로그램 성능 저하를 일으킬 수 있으니 주의해야 한다.
이 키워드를 사용할 경우 자바 내부적으로 메서드나 변수에 동기화를 걸기 위해 block과 unblock을 처리하게 되는데 이러한 처리들이 너무 많아지게 되면 성능저하를 일으키기 때문이다.
-> 메서드에서 사용하는 방법
public synchronized void method(){코드}
-> 객체 변수에서 사용하는 경우(blick문)
private Object obj = new Object();
public void exampleMethod(){ synchronized(obj) {코드}}

BufferReader 고려해보기
자바는 Stream을 통해 입출력이 이루어지며, 파일을 읽고 처리하는 작업을 IO라고 한다.
여기서 입력은 모두 java.io.InputStream 클래스로부터 상속받으며, 출력은 java.io.Reader 클래스로 부터 상속받는다.
BufferdReader 클래스도 역시 FileRead 클래스처럼 문자열 단위나 문자열 배열 단위로 읽는 기능을 제공하지만, 추가적으로 readLine() 메서드로 라인 단위로 읽을 수 있다.
이러한 BufferdReader를 사용하면 FileReader 보다 더 빠른 응답 속도를 가질 수 있다.

로그를 최대한 줄이기
의미없는 디버그용 로그를 print 하기 위해 서버의 리소드와 디스크가 낭비될 수 있다.
때문에 운영 서버의 소스에 있는 시스템 로그의 경우 제거하는 것이 좋다.
물론 이 로그가 필요한 경우가 꼭 있을 경우는 로그를 제거하는 것이 아닌 로그 처리 여부를 추가해주면 된다.
또한 로그를 깔끔하게 처리해주는 slf4j와 LogBack을 사용하는 것이 좋다.
slf4jfmf dldydgkaus answkduf tkdldp {}를 넣고 데이터들을 ',' 로 구분해주는데 이경우 로그를 출력하지 않을 경우 문자열을 더해주는 연산을 하지 않는다.

js, jsx 확장자명 차이
jsx는 자바스크립트에서 xml을 추가한 확장형 문법이다.
자바스크립트에서 html 문법을 사용할수 있다.
기능에는 차이가 없으나 xml 문법을 추가로 사용하기 때문에 팀 내 convention에 관련하여 협의가 필요한 부분이라고 한다.
사용이 필수는 아니지만 ui 관련 작업을 할 때 시각적으로 더 도움이 된다고 생각하는 경우가 많고, 더 정확한 에러 및 경고메시지를 표시할 수 있게 해준다.
