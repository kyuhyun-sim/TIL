트랜잭션
트랜잭션이란 데이터베이스의 상태를 변화시키는 하나의 논리적인 작업 단위이다. 트랜잭션에는 여러 개의 연산이 수행될 수 있고, 수행중에 한작업이라도 실패하면 전부를 rollback하고 모두 성공해야 commit한다.

배열과 링크드 리스트의 차이
둘다 데이터를 나열시켜준다는 공통점을 가지고 있지만 사용하기에 따라 프로그램 성능이 달라질수 있다.
먼저 배열(Array)에 대해 말하자면 데이터 입력이 순차적으로 이루어지며, 물리적 주소 또한 순차적이다. 인덱스가 있어 원하는 데이터에 한번에 접근 가능하기 때문에 데이터 접근 속도가 매우 빠르다. 데이터 삽입, 삭제에 취약하다. 배열 특성상 데이터 삽입, 삭제가 이루어지면 해당 위치의 다음 순서의 데이터의 위치 변경이 이루어지기 때문이다. 배열의 크기가 처음에 결정되어서(unresizable) 변경이 불가능하다.

연결리스트(LINKNED LIST)의 경우 데이터 입력이 논리적 순서로 이루어지며 물리적 주소는 순차적이지 않다. 인덱스를 가지고 있는 배열과는 다르게 리스트는 인덱스 대신 현재 위치의 이전 및 다음 위치에 대한 정보가 있다. 데이터 접근 시 연결되어 있는 링크를 따라가야 하기 때문에 배열에 비해 속도가 떨어진다. 데이터 삽입, 삭제는 논리적 주소만 바꿔주면 되기 때문에 용이하다. 언제든지 메모리 할당/해제를 해서 크기를 변경할 수 있다.(resizable)

JOIN
내부 조인 (INNER JOIN)
일반적으로 가장 많이 사용하는 JOIN으로 쉽게 설명하면, 두 테이블에 공통적으로 존재하는 것을 찾을 때 사용한다.

외부 조인 (OUTER JOIN) - LEFT OUTER JOIN
왼쪽 테이블을 기준으로 검색을 하는 것이다. 
즉, 왼쪽 테이블의 값들은 모두 출력하고 오른쪽 테이블에서는 조인 조건에 맞는 값들은 출력이 되고 왼쪽 테이블을 기준으로 오른쪽 테이블에 존재 하지 않는 값은 NULL로 검색이 된다.

외부 조인 (OUTER JOIN) - RIGHT OUTER JOIN
RIGHT OUTER JOIN의 경우는 LEFT와 반대로 이해하면 된다. 
오른쪽 테이블의 값들은 모두 출력하고 왼쪽 테이블에서는 조인 조건에 맞는 값들은 출력이 되고 조인 조건에 맞는 값이 없는 경우는 NULL로 검색이 된다.

외부 조인 (OUTER JOIN) - FULL OUTER JOIN
LEFT와 RIGHT의 결과를 합쳐 놓은 것이다.

RDBMS vs NOSQL
관계형 데이터베이스 관리 시스템(RDBMS, Relational Database Management System)의 핵심적인 특징은 두가지다. 
첫째, 모든 정보는 정해진 데이터 스키마에 따라 행과 열을 갖춘 테이블 형태로 저장된다. 
둘째, 관계형 데이터베이스에서는 데이터의 집합인 엔티티끼리 서로 관계를 맺을 수 있다. 
(1:1, 1:N, N:M 관계) 관계를 이용하면 하나의 테이블에서 중복 없이 하나의 데이터만을 관리할 수 있다. 
데이터는 테이블에 레코드로 저장되며, 각 테이블마다 필드의 이름과 데이터 유형(스키마)으로 정의된 구조가 있습니다. 따라서 스키마를 준수하지 않은 레코드는 테이블에 추가되지 않는다. 
RDBMS는 일반적으로 SQL(Structured Query Language)로 관리하는 것이 표준화되어 있다. 
NoSQL(Not Only SQL)은 관계형 데이터베이스가 아니며, 스키마 없이 혹은 느슨한 형태의 스키마로도 사용할 수 있다. 
여기에서 데이터 테이블은 그냥 하나의 테이블로, 관계를 설정하지도 않고 JOIN도 할 수 없다.

RDBMS 
장점: 정해진 스키마에 따라 데이터가 저장되므로 데이터 구조가 명확하고, 각 관계를 따라 저장된 데이터는 중복 없음이 보장된다. 
단점: 테이블 간 관계로 얽혀 있어 시스템이 커진다면 쿼리가 복잡해질 수 있다. 
또한 성능 향상을 위해 서버 자체의 성능을 Scale-up하는 방법 밖에 없기 때문에 비용이 기하급수적으로 늘어날 수 있다. 

NoSQL 
장점: 스키마가 없기 떄문에 데이터 구조가 자유롭다. 
언제든지 데이터를 조정하거나 새로운 필드 추가가 가능하다. 
데이터 분산이 용이하기 때문에 대량의 데이터를 빠르게 처리해야 하는 요즘 상황에 적합할 수 있다. 
성능 향상을 위해서도 Scale-Up과 Scale-Out 모두 가능하다. 
단점: 데이터 중복 문제가 발생할 수 있고 스키마가 존재하지 않으므로 데이터 구조가 명확하지 않다.

DB를 선택하는 기준
RDBMS는 데이터 구조가 명확하고 명확한 스키마가 중요할 때 사용할 수 있다. 
데이터 중복이 없음이 보장되므로 재무관련, 보안, 개인 건강정보 시스템과 같은 곳에서 선택할 만 하다. 
반면 NoSQL은 막대한 데이터를 저장해야 할 필요가 있고 작성 속도가 빨라야 하는 데이터 분석, 빠른 프로토타입 작업 등에서 사용할 수 있다.

오버라이딩과 오버로딩
오바라이딩(Overriding)은 상위 클래스의 메소드를 재정의 하는 것을 의미한다. 
또한, 런타임 다형성이기도 하다. 
오버로딩(Overloading)은 같은 클래스 내에서 동일한 메소드 이름을 가지지만, 매개 변수의 타입, 개수를 다르게 구현할 수 있는 것을 의미한다. 
또한, 컴파일 타임 다형성이기도 합니다. 따라서, 오버라이딩이 될 수 있다. 
추가로 '@Override'를 써야하는 이유를 꼭 생각해봐야한다. 
이 어노테이션은 컴파일 타임에 오버라이딩에 대한 안정성을 부여해주기 때문에 반드시 써주는 것이 좋다.

즉시 로딩과 지연 로딩의 차이
즉시 로딩은 데이터를 조회할 때 연관된 데이터까지 한 번에 불러오는 것이고, 지연 로딩은 필요한 시점에 연관된 데이터를 불러오는 것이라고 할 수 있다.