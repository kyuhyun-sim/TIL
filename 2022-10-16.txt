String과 StringBuffer에 차이
String 객체는 한 번 값이 할당되면 그 공간은 변하지 않는다. 
StringBuffer 객체는 한 번 값이 할당되더라도 한 번 더 다른 값이 할당되면 할당된 공간이 변하는 특성을 갖고 있다. 
여기서 할당된 공간이 변하지 않는 특성을 불변(Immutable), 할당된 공간이 변하는 특성을 가변(mutable)라고 한다.

MVC
Model - View - Controller 의 약자 소프트웨어 개발 디자인 패턴을 말한다.
여기서 모델은 어플리케이션이 무엇을 할 것인지를 정의하고 데이터와 로직을 관리한다.

뷰는 화면에 무엇인가를 보여줄 것인지를 나타낸다. 
컨트롤러 하위에 종속되어 모델 혹은 컨트롤러가 처리한 결과물을 화면에 보여주고자 할 때 사용되어 진다.

마지막으로 컨트롤러의 경우 모델이 어떻게 처리할지를 알려주는 역할로써 로직 부분에 해당된다.
View 에서 사용자의 요청을 받아 로직을 통하여 모델과 상호 작용하여 View에 업데이트 요청을 하게 된다.

JPA에서 Entity를 설계할때 주의점
엔티티에는 가급적 Setter를 사용하지 말자.
Setter가 모두 열려있다 -> 변경 포인트가 너무 많아서 유지보수가 어렵다

모든 연관관계는 지연로딩(fetch = FetchType.LAZY)으로 설정하자
즉시로딩은 특정 엔티티를 조회할 때(로딩될 떄) 연관된 모든 엔티티를 조회한다.
기본적으로 전부 지연로딩(LAZY)로 셋팅을 하고 필요에 따라 연관된 원하는 엔티티를 같이 조회할 경우 fetch join 또는 엔티티티 그래프로 최적화를 하는 것이 좋다.

cascade를 사용하여 Persist를 전파하자 (영속성 전이)
상위 엔티티가 변경될 경우 상위 엔티티의 연관된 하위 엔티티 같이 변경을 전파 해주는 옵션이다.
즉, 특정 엔티티를 영속상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들 수 있다.

컬렉션은 필드에서 초기화 하자. 
컬렉션은 필드에서 바로 초기화 하는것이 안전하다.
'NULL'문제에서 안전하다 하이버네이트는 엔티티를 영속화 할 때, 컬렉션을 감싸서 하이버네이트가 제공하는 내장 컬렉션으로 변경한다 만약 'getOrders()'처럼 임의의 메서드에서 컬렉션을 잘못 생성하면 하이버네이트 내부 메커니즘에 문제가 발생할 수 있다. 
따라서 필드레벨에서 생성하는 것이 가장 안전하고 코드도 간결하다

데이터베이스에서 인덱스를 사용하는 이유 및 장단점
데이터베이스의 테이블에 대한 검색 속도를 향상시켜주는 자료구조이다. 테이블의 특정 컬럼(Column)에 인덱스를 생성하면, 해당 컬럼의 데이터를 정렬한 후 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장된다. 컬럼의 값과 물리적 주소를 (key, value)의 한 쌍으로 저장한다.

장점
인덱스의 장점으로는 앞에서 말했듯이 테이블을 검색하는 속도와 성능이 향상된다. 또 그에 따라 시스템의 전반적인 부하를 줄일 수 있다. 핵심은 인덱스에 의해 데이터들이 정렬된 형태를 갖는다는 것이다. 기존엔 Where문으로 특정 조건의 데이터를 찾기 위해서 테이블의 전체를 조건과 비교해야 하는 '풀 테이블 스캔(Full Table Scan)' 작업이 필요했는데, 인덱스를 이용하면 데이터들이 정렬되어 있기 때문에 조건에 맞는 데이터를 빠르게 찾을 수 있다. 또 ORDER BY 문이나 MIN/MAX 같은 경우도 이미 정렬이 되어 있기 때문에 빠르게 수행할 수 있다.

단점
인덱스를 관리하기 위한 추가 작업이 필요하다.
또한 추가 저장 공간 필요 하다.
잘못 사용하는 경우 오히려 검색 성능 저하시키기도 한다.

인덱스를 항상 정렬된 상태로 유지해야 하기 때문에 인덱스가 적용된 컬럼에 삽입(INSERT), 삭제(DELETE), 수정(UPDATE) 을 시행 시에 추가 작업이 필요하다.

인덱스의 수정도 추가적으로 필요하기 때문에 데이터의 수정이 잦은 경우 성능이 낮아진다. 또 데이터의 인덱스를 제거하는 것이 아니라 '사용하지 않음'으로 처리하고 남겨두기 때문에 수정 작업이 많은 경우 실제 데이터에 비해 인덱스가 과도하게 커지는 문제점이 발생할 수 있다. 별도의 메모리 공간에 저장되기 때문에 추가 저장 공간이 많이 필요하게 된다. 또한 인덱스는 전체 데이터의 10 ~ 15% 이상의 데이터를 처리하거나, 데이터의 형식에 따라 오히려 성능이 낮아질 수 있다. 예를 들어 나이나 성별과 같이 값의 range가 적은 컬럼인 경우, 인덱스를 읽고 나서 다시 많은 데이터를 조회해야 하기 때문에 비효율적이다.