DI(의존성 주입)

하나의 객체가 다른 객체의 의존성을 제공하는 기술이다.
의존성 주입의 의도는 객체의 생성과 사용의 관심을 분리하는 것이다.
이는 가독성과 코드 재사용을 높혀준다.
또한 의존성 주입을 통해 애플리케이션이나 클래스가 객체의 생성 방식과 독립적일 수 있게 도와주며, 객체의 생성 방식을 분리된 구성 파일에서 지정할 수 있게 해주며, 애플리케이션이 다른 구성을 지원할 수 있게 해준다.
또한 프로그램 디자인이 결합도를 느슨하게 되도록하고 의존관계 역전 원칙과 단일 책임 원칙을 따르도록 클라이언트의 생성에 대한 의존성을 클라이언트의 행위로부터 분리되게 해준다.
의존성 주입의 기본 단위인 주입은 새롭거나 관습적인 메커니즘이 아니다.
매개변수 전달과 동일하게 동작한다.

장점으로는 모듈들을 쉽게 교체할 수 있는 구조로 인해 테스트가 쉽고 마이그레이션하기도 쉽다.
또한 구현할 때 추상화 레이어를 넣고 이를 기반으로 구현체를 넣어주기 때문에 어플리케이션 의존성 방향이 일관되고, 어플리케이션을 쉽게 추론 가능해지기에, 모듈 간 관계가 조금 더 명확해진다.

단점으로는 모듈들의 분리가 증가하고 클래스 수 증가하기에 복잡성이 증가하게 된다.
이러한 복잡성이 증가됨에 따라 약간의 런타임 페널티가 생기기도 한다.
그리고 종속성은 런타임에서 해결되기 때문에 종속성 오류는 컴파일 시간에 포착할 수 없다.

Lombok의 안정성 문제로 사용을 지양하기에 Lombok 없이 의존성을 주입하는 방법을 찾아보았다.
아래의 코드는 간단하게 작성한 예시이다.
핵심은 클라이언트에 사용할 service를 private final 키워드를 사용해 선언하며, 생성자로 의존성 주입 후 해당 메소드 위에 @Autowired 어노테이션 추가하는 것이다.

@Controller
public class ExampleController {
    private final ExampleService service;

    @Autowired
    public ExampleController(ExampleService service) {
        this.service = service;
    }

    @PostMapping("/example")
    public String example(Map<String, String> receiveData){
        return service.example(receiveData);
    }
}
