@Transactional(readOnly = true)
readOnly = true 속성을 주면 스프링 프레임워크가 하이버네이트 세션 플러시 모드를 MANUAL로 설정한다.
이렇게 하면 강제로 플러시를 호출하지 않는 한 플러시가 일어나지 않는다. 따라서 트랜잭션을 커밋해도 영속성 컨텍스트를 플러시 하지 않는다. 플러시 하지 않으니 당연히 등록, 수정, 삭제는 동작하지 않는다. 하지만 플러시 할 때 일어나는 스냅샷 비교와 같은 무거운 로직들을 수행하지 않으므로 성능이 향상된다.
물론 트랜잭션을 시작했으므로 트랜잭션 시작, 로직 수행, 트랜잭션 커밋의 과정은 이루어지고, 단지 영속성 컨텍스트를 플러시 하지 않을 뿐이다.

@QueryHints(value = @QueryHint(name = "org.hibernate.readOnly", value = "true"))
기본적으로 JPA가 변경감지에 의해 update 쿼리를 날릴려면 원본을 캐시에 저장하고 관리하는 entity 객체 또한 따로 갖고 있는다. 하여 이를 위해 영속성 컨텍스트는 항상 원본(스냅샷)과 관리하는 사본 객체 두 객체를 메모리에 저장하게 된다. 이게 성능 이슈가 될 수도 있다. 읽기만 할 때는 필요없기 때문에 같은 엔티티 객체를 두 개를 갖는 것은 메모리 비용을 허비할 수가 있다.
그래서 JPA Hint를 통해 읽기 전용이라고 알려주고 캐시에 원본(스냅샷)을 저장하지 않도록 하여 공간 비용을 최적화할 수 있다.

@QueryHints(value = { @QueryHint(name = "org.hibernate.readOnly", value = "true")},
            forCounting = true)
forCounting: 반환 타입으로 Page 인터페이스를 적용하면 추가로 호출하는 페이징을 위한 count 쿼리도 쿼리 힌트 적용(기본값 true )

n:1 관계의 n+1문제를 해결하기 위해 with 페치조인 적용하였다.

1:n 관계의 경우 배치사이즈를 적용해준다고 한다.