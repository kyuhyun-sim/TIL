n+1문제
연관 관계가 설정된 엔티티를 조회할 경우에 조회된 데이터 갯수만큼 연관관계의 조회 쿼리가 추가로 발생하여 데이터를 읽어오는 현상이다.

fetch모드를 LAZY 지연로딩으로 한 경우 n+1이 발생하지 않는 것처럼 보이나 부모 엔터티를 사용하려는 순간 n+1문제가 발생하게 된다.
즉 즉시로딩은 바로 n+1문제가 발생하며, 지연로딩은 객체를 탐색하려는 순간 n+1문제를 발생시키기에 결국은 모두 n+1문제를 발생시키게 된다.

n+1 문제의 발생 이유는 jpa가 jpql(객체지향 쿼리)을 분석해서 SQL을 생성할때 글로벌 Fetch 전략을 참고하지 않고 오로지 JPQL 자체만을 사용하기 때문.

이런 n+1문제를 해결하기 위해서는 Fetch Join, EntityGraph 어노테이션, Batch Size등이 있지만 이중 EntityGraph는 잘못 사용하면 엄청 어려워지기에 무시하는 것이 좋다.
이중 Fetch join으로 해결하는 방법은 간단하다.
별도의 메소드를 repository안에 만들어 주어 @Query 어노테이션과 함께 "join fetch 엔티티.연관관계_엔티티" 구문을 만들어 주면 된다.
ex)public interface TeamRepository extends JpaRepository<Team, Long> {
    @Query("select t from Team t join fetch t.users")
    List<Team> findAllFetchJoin();
}

별도의 지정을 해주지 않는한 위의 Fecth join은 sql의 inner join 구문으로 변경되어 실행된다.

Batch Size
이 방법은 정확히 말하자면 n+1문제를 안 일어나게 하는 방법은 아니고 N?+1 문제가 발생하더라도 select * from user where team_id = ? 이 아닌 select * from user where team_id in (?, ?, ? ) 방식으로 N+1 문제가 발생하게 하는 방법이다.
select * from user where team_id = ? 이 아닌 select * from user where team_id in (?, ?, ? ) 방식으로 N+1 문제가 발생하게 하는 방법이다.
이 Batch Size는 실무에서 보통 1000이하로 설정하여 사용한다.


엔티티 매니저 팩토리는 생성되는 시점에 DB 커넥션 풀을 생성해 둔 후, 고객의 요청이 들어올 때마다 엔티티 매니저를 생성한다.
엔티티 매니저는 DB 연결이 필요한 시점(보통 트랜잭션이 시작되는 경우)에 커넥션 풀에 있는 connection을 얻는다.

엔티티 매니저 팩토리는 생성되는 시점에 DB 커넥션 풀을 생성하기에 생성 비용이 매우 크다.
그러나 엔티티 매니저의 생성 비용은 거의 들지 않으므로, 엔티티 매니저 팩토리는 필요에 따라 앤티티 매니저를 생성하여 사용한다.
엔티티 매니저 팩토리는 스레드 세이프(Thread Safe)하다.
즉 여러 스레드가 동시에 접근하여도 안전한 반면, 엔티티 매니저는 여러 스레드가 동시에 접근할 경우 동시성 문제가 발생하게 된다.
때문에 팩토리와 달리 엔티티 매니저는 절대로 공유해서는 안됩니다.

엔티티(Entity)를 저장하고 관리하는 저장소의 개념으로 영속성 컨텍스트는 엔티티 매니저를 통해서 접근할 수 있다.
영속성 컨텍스트에 관리되는 엔티티의 상태를 영속 상태라 한다.
이런 영속 상태가 되기 위해서는 반드시 식별자가 존재해야 한다.

영속성 컨텍스트는 내부에 1차 캐시를 가지고 있다.
자세히 살펴보면 멤버의 @id 값과, 해당 엔터티 객체가 나뉘어 들어가 있다.
비영속과 영속을 구분하는 방법은 다음과 같다
//엔티티를 생성한 상태 (비영속)
Member member = new Member();
member.setId("member1");
member.serUsername("회원1");

//엔티티를 영속화, em은 EntityManager
em.persist(member);

영속성 컨텍스트의 개념이 어려우면 1차캐쉬라 생각하면 된다.
서버와 DB 사이에 엔티티를 저장하는 논리적 영역이라 할 수 있으면, 엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다.

1차 캐시 뿐만 아니라 Collection에서 객체를 빼오듯이 같은 객체를 반환하게 되면 새로운 객체가 나오는 것이 아니라 동일한 객체가 반환되게 동일성을 보장해준다.
jpql(객체지향 쿼리)를 사용함으로서 영속성 컨텍스트의 데이터가 갱신되게 도와준다.
영속성 상태에서의 객체는 객체의 데이터가 변경되면 변경 감지를 통해 자동 업데이트 되며, 엔티티 매니저에서 flush가 돼 넣어지고, commit이 된다.
강제 Flushsms EntityManager.flush(), 보통은 트래잭션이 종료(영속성 컨텍스트는 트랜잭션 범위로 만들어지기 때문)되거나,  JPQL 쿼리(DB에서 서버로 데이터를 가져오기때문)가 실행되기 직전 flush된다.

